/**
 * @fileoverview ÂÆûÊó∂ÊÄßËÉΩÁõëÊéßHook
 * @description Êèê‰æõWebSocketÂÆûÊó∂Êõ¥Êñ∞ÂíåÊÄßËÉΩÊï∞ÊçÆÁÆ°ÁêÜ
 */

"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { api } from '@/lib/api';

interface RealTimePerformanceData {
  currentQPS: number;
  averageResponseTime: number;
  activeConnections: number;
  recentSlowQueries: number;
  cacheHitRate: number;
  systemHealth: 'excellent' | 'good' | 'warning' | 'critical';
  redisConnected: boolean;
  databaseConnected: boolean;
  // P1Á∫ßÁºìÂ≠ò‰ºòÂåñÁõëÊéßÊï∞ÊçÆ
  cacheStats: {
    hits: number;
    misses: number;
    hitRate: number;
    penetrationPrevented: number;
    warmupExecuted: number;
    dynamicTTLAdjustments: number;
  };
  // P1Á∫ßÊùÉÈôêÊéßÂà∂ÁõëÊéßÊï∞ÊçÆ
  permissionStats: {
    totalChecks: number;
    averageCheckTime: number;
    cacheHits: number;
    auditLogsGenerated: number;
    resourceAccessChecks: number;
  };
}

interface UseRealTimePerformanceOptions {
  /** Êõ¥Êñ∞Èó¥ÈöîÔºàÊØ´ÁßíÔºâÔºåÈªòËÆ§5000ms */
  updateInterval?: number;
  /** ÊòØÂê¶ÂêØÁî®WebSocketÂÆûÊó∂Êõ¥Êñ∞ */
  enableWebSocket?: boolean;
  /** ÊòØÂê¶Ëá™Âä®ÂºÄÂßãÁõëÊéß */
  autoStart?: boolean;
}

interface UseRealTimePerformanceReturn {
  /** ÂÆûÊó∂ÊÄßËÉΩÊï∞ÊçÆ */
  data: RealTimePerformanceData | null;
  /** ÊòØÂê¶Ê≠£Âú®Âä†ËΩΩ */
  isLoading: boolean;
  /** ÊòØÂê¶ËøûÊé•‰∏≠ */
  isConnected: boolean;
  /** ÈîôËØØ‰ø°ÊÅØ */
  error: string | null;
  /** ÊúÄÂêéÊõ¥Êñ∞Êó∂Èó¥ */
  lastUpdated: Date | null;
  /** ÊâãÂä®Âà∑Êñ∞Êï∞ÊçÆ */
  refresh: () => Promise<void>;
  /** ÂºÄÂßãÁõëÊéß */
  start: () => void;
  /** ÂÅúÊ≠¢ÁõëÊéß */
  stop: () => void;
  /** Êõ¥Êñ∞ÈÖçÁΩÆ */
  updateConfig: (options: Partial<UseRealTimePerformanceOptions>) => void;
}

export function useRealTimePerformance(
  options: UseRealTimePerformanceOptions = {}
): UseRealTimePerformanceReturn {
  const {
    updateInterval = 5000,
    enableWebSocket = false, // ÊöÇÊó∂Á¶ÅÁî®WebSocketÔºå‰ΩøÁî®ËΩÆËØ¢
    autoStart = true,
  } = options;

  const [data, setData] = useState<RealTimePerformanceData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const [isActive, setIsActive] = useState(autoStart);

  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const configRef = useRef(options);

  // Êõ¥Êñ∞ÈÖçÁΩÆ
  const updateConfig = useCallback((newOptions: Partial<UseRealTimePerformanceOptions>) => {
    configRef.current = { ...configRef.current, ...newOptions };
  }, []);

  // Ëé∑ÂèñÂÆûÊó∂ÊÄßËÉΩÊï∞ÊçÆ
  const fetchRealTimeData = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      // ‰∏ªË¶ÅÈÄöËøátRPC APIËé∑ÂèñÂÆûÊó∂ÊåáÊ†áÔºåÂåÖÂê´ÁºìÂ≠òÁªüËÆ°
      const [realTimeMetrics, permissionStatsResponse, redisHealthResponse] = await Promise.all([
        // ‰ΩøÁî®fetchÁõ¥Êé•Ë∞ÉÁî®tRPC API - Ëøô‰∏™APIÁé∞Âú®ÂåÖÂê´‰∫ÜÂÆåÊï¥ÁöÑÁºìÂ≠òÁªüËÆ°
        fetch('/api/trpc/admin.performance.getRealTimeMetrics?batch=1&input=%7B%220%22%3A%7B%22json%22%3Anull%7D%7D')
          .then(res => res.ok ? res.json() : null)
          .catch(() => null),
        // Ë∞ÉÁî®ÊùÉÈôêÁªüËÆ°API
        fetch('/api/permissions/stats').then(res => res.ok ? res.json() : null).catch(() => null),
        // Ë∞ÉÁî®RedisÂÅ•Â∫∑Ê£ÄÊü•API
        fetch('/api/redis/health').then(res => res.ok ? res.json() : null).catch(() => null),
      ]);

      // Ëß£ÊûêtRPCÂìçÂ∫îÊ†ºÂºè - ÊîØÊåÅÂ§öÁßçÂèØËÉΩÁöÑÂìçÂ∫îÁªìÊûÑ
      let realTimeData: any = null;

      // Â∞ùËØï‰∏çÂêåÁöÑÂìçÂ∫îÁªìÊûÑ - Êåâ‰ºòÂÖàÁ∫ßÊéíÂ∫è
      console.log('üîç Ëß£ÊûêÂâçÊ£ÄÊü•:', {
        hasRealTimeMetrics: !!realTimeMetrics,
        isArray: Array.isArray(realTimeMetrics),
        firstItem: realTimeMetrics?.[0],
        hasJson: !!realTimeMetrics?.[0]?.json,
        hasJsonData: !!realTimeMetrics?.[0]?.json?.data,
        hasResultData: !!realTimeMetrics?.[0]?.result?.data,
        resultDataStructure: realTimeMetrics?.[0]?.result?.data
      });

      if (realTimeMetrics?.[0]?.json?.data) {
        // Áõ¥Êé•ÁöÑ json.data ÁªìÊûÑ
        realTimeData = realTimeMetrics[0].json.data;
        console.log('‚úÖ ‰ΩøÁî® json.data Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.[0]?.result?.data?.json?.data) {
        // ÂµåÂ•óÁöÑ result.data.json.data ÁªìÊûÑ
        realTimeData = realTimeMetrics[0].result.data.json.data;
        console.log('‚úÖ ‰ΩøÁî® result.data.json.data Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.[0]?.result?.data) {
        realTimeData = realTimeMetrics[0].result.data;
        console.log('‚úÖ ‰ΩøÁî® result.data Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.[0]?.data) {
        realTimeData = realTimeMetrics[0].data;
        console.log('‚úÖ ‰ΩøÁî® data Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.[0]?.result) {
        realTimeData = realTimeMetrics[0].result;
        console.log('‚úÖ ‰ΩøÁî® result Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.[0]) {
        realTimeData = realTimeMetrics[0];
        console.log('‚úÖ ‰ΩøÁî® [0] Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics?.data) {
        realTimeData = realTimeMetrics.data;
        console.log('‚úÖ ‰ΩøÁî® metrics.data Ë∑ØÂæÑ:', realTimeData);
      } else if (realTimeMetrics && typeof realTimeMetrics === 'object') {
        realTimeData = realTimeMetrics;
        console.log('‚úÖ ‰ΩøÁî® metrics Ë∑ØÂæÑ:', realTimeData);
      }

      // ‰ªétRPC APIËé∑ÂèñÁºìÂ≠òÁªüËÆ°ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ªéÁã¨Á´ãAPIËé∑Âèñ
      const permissionStats = permissionStatsResponse?.success ? permissionStatsResponse.data : null;
      const redisHealth = redisHealthResponse?.success ? redisHealthResponse.data : null;

      // ËØ¶ÁªÜË∞ÉËØïÊó•Âøó
      console.log('üîç ÂÆûÊó∂ÊÄßËÉΩÊï∞ÊçÆË∞ÉËØï:', {
        rawRealTimeMetrics: realTimeMetrics,
        parsedRealTimeData: realTimeData,
        databaseConnected: realTimeData?.databaseConnected,
        redisConnected: realTimeData?.redisConnected,
        systemHealth: realTimeData?.systemHealth,
        dataType: typeof realTimeData,
        dataKeys: realTimeData ? Object.keys(realTimeData) : null,
        redisHealthData: redisHealth,
      });

      // Êõ¥ËØ¶ÁªÜÁöÑJSONË∞ÉËØï
      if (realTimeData && typeof realTimeData === 'object') {
        console.log('üìä ÂÆåÊï¥Êï∞ÊçÆÁªìÊûÑ:', JSON.stringify(realTimeData, null, 2));
      }

      if (realTimeData) {
        const enhancedData: RealTimePerformanceData = {
          // Âü∫Á°ÄÊÄßËÉΩÊï∞ÊçÆ
          currentQPS: realTimeData.currentQPS || 0,
          averageResponseTime: realTimeData.averageResponseTime || 0,
          activeConnections: realTimeData.activeConnections || 0,
          recentSlowQueries: realTimeData.recentSlowQueries || 0,
          cacheHitRate: realTimeData.cacheHitRate || 0,
          systemHealth: realTimeData.systemHealth || 'good',
          redisConnected: redisHealth?.isConnected ?? realTimeData.redisConnected ?? false,
          databaseConnected: realTimeData.databaseConnected ?? false,

          // ÈõÜÊàêP1Á∫ßÁºìÂ≠òÁªüËÆ° - ‰ºòÂÖà‰ΩøÁî®tRPC API‰∏≠ÁöÑÁºìÂ≠òÁªüËÆ°
          cacheStats: {
            hits: realTimeData.cacheStats?.hits || 0,
            misses: realTimeData.cacheStats?.misses || 0,
            hitRate: realTimeData.cacheHitRate || 0, // ‰ΩøÁî®tRPC APIÁöÑÁºìÂ≠òÂëΩ‰∏≠Áéá
            penetrationPrevented: realTimeData.cacheStats?.penetrationPrevented || 0,
            warmupExecuted: realTimeData.cacheStats?.warmupExecuted || 0,
            dynamicTTLAdjustments: realTimeData.cacheStats?.dynamicTTLAdjustments || 0,
          },

          // ÈõÜÊàêP1Á∫ßÊùÉÈôêÁªüËÆ°
          permissionStats: permissionStats ? {
            totalChecks: permissionStats.totalChecks || 0,
            averageCheckTime: permissionStats.averageCheckTime || 0,
            cacheHits: permissionStats.cacheHits || 0,
            auditLogsGenerated: permissionStats.auditLogsGenerated || 0,
            resourceAccessChecks: permissionStats.resourceAccessChecks || 0,
          } : {
            totalChecks: 0,
            averageCheckTime: 0,
            cacheHits: 0,
            auditLogsGenerated: 0,
            resourceAccessChecks: 0,
          },
        };

        setData(enhancedData);
        setLastUpdated(new Date());
        setIsConnected(true);

        // Ë∞ÉËØïÊúÄÁªàÊï∞ÊçÆ
        console.log('‚úÖ ÊúÄÁªàÂ§ÑÁêÜÂêéÁöÑÊï∞ÊçÆ:', {
          databaseConnected: enhancedData.databaseConnected,
          redisConnected: enhancedData.redisConnected,
          systemHealth: enhancedData.systemHealth,
        });
      } else {
        throw new Error('Ëé∑ÂèñÂÆûÊó∂ÊåáÊ†áÂ§±Ë¥•ÔºöÊó†Ê≥ïËß£ÊûêÂìçÂ∫îÊï∞ÊçÆ');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Êú™Áü•ÈîôËØØ';
      setError(errorMessage);
      setIsConnected(false);
      console.error('Ëé∑ÂèñÂÆûÊó∂ÊÄßËÉΩÊï∞ÊçÆÂ§±Ë¥•:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // ÊâãÂä®Âà∑Êñ∞
  const refresh = useCallback(async () => {
    await fetchRealTimeData();
  }, [fetchRealTimeData]);

  // ÂºÄÂßãÁõëÊéß
  const start = useCallback(() => {
    setIsActive(true);
  }, []);

  // ÂÅúÊ≠¢ÁõëÊéß
  const stop = useCallback(() => {
    setIsActive(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
    setIsConnected(false);
  }, []);

  // WebSocketËøûÊé•ÁÆ°ÁêÜ
  const setupWebSocket = useCallback(() => {
    if (!enableWebSocket || typeof window === 'undefined') {
      return;
    }

    try {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/api/ws/performance`;

      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('WebSocketËøûÊé•Â∑≤Âª∫Á´ã');
        setIsConnected(true);
        setError(null);
      };

      ws.onmessage = (event) => {
        try {
          const receivedData = JSON.parse(event.data);
          if (receivedData.type === 'performance-update') {
            setData(receivedData.data);
            setLastUpdated(new Date());
          }
        } catch (err) {
          console.error('Ëß£ÊûêWebSocketÊ∂àÊÅØÂ§±Ë¥•:', err);
        }
      };

      ws.onclose = () => {
        console.log('WebSocketËøûÊé•Â∑≤ÂÖ≥Èó≠');
        setIsConnected(false);
        wsRef.current = null;

        // Ëá™Âä®ÈáçËøû
        if (isActive) {
          setTimeout(() => {
            if (isActive) {
              setupWebSocket();
            }
          }, 5000);
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocketÈîôËØØ:', error);
        setError('WebSocketËøûÊé•ÈîôËØØ');
        setIsConnected(false);
      };
    } catch (err) {
      console.error('ÂàõÂª∫WebSocketËøûÊé•Â§±Ë¥•:', err);
      setError('Êó†Ê≥ïÂª∫Á´ãWebSocketËøûÊé•');
    }
  }, [enableWebSocket, isActive]);

  // ËΩÆËØ¢ÁÆ°ÁêÜ
  const setupPolling = useCallback(() => {
    if (enableWebSocket) {
      return;
    }

    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }

    intervalRef.current = setInterval(() => {
      if (isActive) {
        fetchRealTimeData();
      }
    }, updateInterval);

    // Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°
    if (isActive) {
      fetchRealTimeData();
    }
  }, [enableWebSocket, isActive, updateInterval, fetchRealTimeData]);

  // ÊïàÊûúÁÆ°ÁêÜ
  useEffect(() => {
    if (isActive) {
      if (enableWebSocket) {
        setupWebSocket();
      } else {
        setupPolling();
      }
    } else {
      stop();
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [isActive, enableWebSocket, setupWebSocket, setupPolling, stop]);

  // È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÂ§ÑÁêÜ
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        // È°µÈù¢ÈöêËóèÊó∂ÊöÇÂÅúÊõ¥Êñ∞
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
          intervalRef.current = null;
        }
      } else {
        // È°µÈù¢ÊòæÁ§∫Êó∂ÊÅ¢Â§çÊõ¥Êñ∞
        if (isActive && !enableWebSocket) {
          setupPolling();
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isActive, enableWebSocket, setupPolling]);

  return {
    data,
    isLoading,
    isConnected,
    error,
    lastUpdated,
    refresh,
    start,
    stop,
    updateConfig,
  };
}
